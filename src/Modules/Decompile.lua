local HttpRbxApiService = game:GetService("HttpRbxApiService")
local HttpService = game:GetService("HttpService")
local Selection = game:GetService("Selection")

local ApplyColorCopy = require(script.Parent.ApplyColorCopy)
local ApplyConfigurationValues = require(script.Parent.ApplyConfigurationValues)
local Branding = require(script.Parent.Branding)
local Logger = require(script.Parent.Logger)
local ExtractedUtil = require(script.Parent.ExtractedUtil)
local ClassicStableDecompiler = require(script.Parent.Parent.OldCompilers["Stable JSON v2.1.0"])
local LuaEncode = require(script.Parent.Parent.MBEPackages.LuaEncode)
local Compilers = require(script.Parent.Compilers)
local CreateOutputScript = require(script.Parent.CreateOutputScript)

local compilerSettings = {
	Offset = Vector3.zero,
	ShowTODO = false,
}

function ModernDecompile(content): (Model?, string?)
	local model
	local success, err = ExtractedUtil.HistoricEvent("Decompile", "Decompile Model", function()
		if content:sub(1, 4) == "http" then
			content = HttpRbxApiService:GetAsync(content)
		end

		local instances, saveData = Compilers:GetSelectedCompiler():Decompile(content, compilerSettings)

		model = Instance.new("Model")
		model.Name = "Decompilation"

		for _, instance in instances do
			instance.Parent = model
		end

		local _, bounds = model:GetBoundingBox()

		model.Parent = workspace

		model:MoveTo(ExtractedUtil.GetInsertPoint(bounds.Magnitude * 2, bounds.Y / 2))

		-- Create a script to put the details in
		local source = `-- The following is a summary of the data contained in the model's save format generated by LuaEncode.\n-- Your model has been selected in the explorer. \nreturn {LuaEncode(saveData, {
			Prettify = true
		})}`
		local details_script = CreateOutputScript(source, Branding.NAME_ABBREVIATION .. "Details", true)
		if details_script then
			details_script.Parent = model
		end

		-- Select model
		Selection:Set({model})

		Logger.print("SUCCESSFULLY DECOMPILED DATA")
	end)
	Logger.print(`Modern decompile returned {success}, {err}`)
	if success then
		return model, nil
	end
	return nil, err
end

function ClassicDecompile(content)
	local DecompileParts
    local decompile_position = CFrame.new(ExtractedUtil.GetInsertPoint(32))
	if content:sub(1, 4) == "http" then
		DecompileParts = ClassicStableDecompiler.Decompile(decompile_position, HttpService:GetAsync(content))
	else
		DecompileParts = ClassicStableDecompiler.Decompile(decompile_position, content)
	end
	if not DecompileParts then warn('[MB:E:E] NO DECOMPILE') return end

	local DecompileGroup = Instance.new("Model")

	for i,v in ExtractedUtil.SearchTableWithRecursion(DecompileParts, function(Element) return typeof(Element) == "Instance" and Element:IsA("BasePart") or typeof(Element) == "table" and Element or Element:GetChildren() end) do
		v.Parent = DecompileGroup
		ApplyColorCopy(v)
		if ExtractedUtil.IsTemplate(v) then
			ExtractedUtil.ApplyTemplates({v})
		end

		if not v:FindFirstChildWhichIsA("ValueBase") then continue end

		for _, v2 in v:GetDescendants() do
			if not v2:IsA("ValueBase") then continue end
			ApplyConfigurationValues(nil, v, v2, v2.Value)
		end
	end

	DecompileGroup.Name = "MBE_Decompile"
	DecompileGroup.Parent = workspace

	Selection:Set({DecompileGroup})
end

return function(save_string: string)
	Logger.print("DECOMPILE STARTED")

	local model = ModernDecompile(save_string)

	if model then
		Logger.print("DECOMPILE SUCCESS")
	else
		Logger.print("MODERN DECOMPILE FAILED, TRYING CLASSIC DECOMPILER")

		local ok, result = pcall(ClassicDecompile, save_string)

		if ok then
			Logger.print("CLASSIC DECOMPILE SUCCESS")
		else
			Logger.print("CLASSIC DECOMPILE FAILED WITH ERROR", result)
		end
	end
end